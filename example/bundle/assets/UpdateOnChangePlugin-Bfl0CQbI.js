import{p as b,k as C,i as q,V as O,Q as Z,n as c}from"./three.module-CrM3Sdgj.js";import{E as H,c as T,N as I,D as j,m as P,a as A,s as Q,b as B}from"./EnvironmentControls-CC2KExwZ.js";import{E as J}from"./lil-gui.module.min-C0dNwVk_.js";const u=new b,x=new b,D=new C,s=new C,f=new C,U=new C,p=new C,W=new C,E=new C,F=new C,l=new Z,G=new C,w=new C,N={},y=new q,V=new J,M=new O,v=new O,z=new O,K=400;class tt extends H{get ellipsoid(){return this.tilesRenderer?this.tilesRenderer.ellipsoid:null}get tilesGroup(){return this.tilesRenderer?this.tilesRenderer.group:null}constructor(t=null,e=null,i=null,r=null){super(t,e,i),this._dragMode=0,this._rotationMode=0,this.maxZoom=.01,this.useFallbackPlane=!1,this.reorientOnDrag=!1,this.inertiaAxis=new C,this.dragQuaternion=new Z,this.inertiaDragMode=0,this.allowNegativeNearPlanes=!0,this.setTilesRenderer(r)}setScene(t){t===null&&this.tilesRenderer!==null?super.setScene(this.tilesRenderer.group):super.setScene(t)}getPivotPoint(t){const{camera:e,tilesGroup:i,ellipsoid:r}=this;return p.set(0,0,-1).transformDirection(e.matrixWorld),u.copy(i.matrixWorld).invert(),y.origin.copy(e.position),y.direction.copy(p),y.applyMatrix4(u),T(y,r,s),s.applyMatrix4(i.matrixWorld),(super.getPivotPoint(t)===null||t.distanceTo(y.origin)>s.distanceTo(y.origin))&&t.copy(s),t}getVectorToCenter(t){const{tilesGroup:e,camera:i}=this;return t.setFromMatrixPosition(e.matrixWorld).sub(i.position)}getDistanceToCenter(){return this.getVectorToCenter(s).length()}getUpDirection(t,e){const{tilesGroup:i,ellipsoid:r}=this;u.copy(i.matrixWorld).invert(),s.copy(t).applyMatrix4(u),r.getPositionToNormal(s,e),e.transformDirection(i.matrixWorld)}getCameraUpDirection(t){const{tilesGroup:e,ellipsoid:i,camera:r}=this;r.isOrthographicCamera?(this._getVirtualOrthoCameraPosition(s),u.copy(e.matrixWorld).invert(),s.applyMatrix4(u),i.getPositionToNormal(s,t),t.transformDirection(e.matrixWorld)):this.getUpDirection(r.position,t)}update(t=Math.min(this.clock.getDelta(),64/1e3)){if(!this.enabled||!this.tilesGroup||!this.camera||t===0)return;const{camera:e,tilesGroup:i,pivotMesh:r}=this;if(this._isNearControls()?this.scaleZoomOrientationAtEdges=this.zoomDelta<0:(this.state!==I&&this._dragMode!==1&&this._rotationMode!==1&&(r.visible=!1),this.scaleZoomOrientationAtEdges=!1),super.update(t),e.isPerspectiveCamera){let o=this.getDistanceToCenter();const n=this._getMaxPerspectiveDistance();o>n&&(s.setFromMatrixPosition(i.matrixWorld).sub(e.position).normalize().multiplyScalar(-1),e.position.setFromMatrixPosition(i.matrixWorld).addScaledVector(s,n),e.updateMatrixWorld(),o=n)}this.updateCameraClipPlanes(e)}updateCameraClipPlanes(t){const{tilesGroup:e,ellipsoid:i}=this;if(t.isPerspectiveCamera){const r=s.setFromMatrixPosition(e.matrixWorld).sub(t.position).length(),o=Math.max(...i.radius),n=.25*o,a=c.clamp((r-o)/n,0,1),d=c.lerp(1,1e3,a);t.near=Math.max(d,r-o-n);const m=u.copy(e.matrixWorld).invert();D.copy(t.position).applyMatrix4(m),i.getPositionToCartographic(D,N);const h=Math.max(i.getPositionElevation(D),K),g=i.calculateHorizonDistance(N.lat,h);t.far=g*2.5+.1,t.updateProjectionMatrix()}else{this._getVirtualOrthoCameraPosition(t.position,t),t.updateMatrixWorld(),u.copy(t.matrixWorld).invert(),s.setFromMatrixPosition(e.matrixWorld).applyMatrix4(u);const r=-s.z;t.near=r-Math.max(...i.radius)*1.1,t.far=r+.1,!this.allowNegativeNearPlanes&&t.near<0&&(t.position.addScaledVector(p,t.near),t.far-=t.near,t.near=0),t.updateProjectionMatrix(),t.updateMatrixWorld()}}resetState(){super.resetState(),this._dragMode=0,this._rotationMode=0}_updatePosition(t){if(this.state!==j){const{enableDamping:e,inertiaDragMode:i,tilesGroup:r,dragQuaternion:o,dragInertia:n,camera:a}=this;e&&(i===1?(o.w===1&&(o.x!==0||o.y!==0||o.z!==0)&&(o.w=Math.min(o.w,1-1e-9)),f.setFromMatrixPosition(r.matrixWorld),l.identity().slerp(o,n.x*t),P(f,l,x),a.matrixWorld.premultiply(x),a.matrixWorld.decompose(a.position,a.quaternion,s)):i===-1&&this._applyZoomedOutRotation(n.x*t,n.y*t))}else if(this._dragMode===1||this._isNearControls()){this._dragMode=1;const{raycaster:e,camera:i,pivotPoint:r,pointerTracker:o,domElement:n,tilesGroup:a}=this,d=D,m=E;o.getCenterPoint(M),A(M.x,M.y,n,M),Q(e,M,i),u.copy(a.matrixWorld).invert(),e.ray.applyMatrix4(u);const h=s.copy(r).applyMatrix4(u).length();V.radius.setScalar(h),i.isPerspectiveCamera?V.intersectRay(e.ray,s)||B(e.ray,h,s):T(e.ray,V,s),s.applyMatrix4(a.matrixWorld),f.setFromMatrixPosition(a.matrixWorld),d.subVectors(r,f).normalize(),m.subVectors(s,f).normalize(),l.setFromUnitVectors(m,d),P(f,l,x),i.matrixWorld.premultiply(x),i.matrixWorld.decompose(i.position,i.quaternion,s),this.inertiaDragMode=1;const{dragInertia:g,dragQuaternion:_}=this;o.getMoveDistance()/t<2*window.devicePixelRatio?(_.slerp(l,.5),g.set(1/t,0,0)):(_.copy(l),g.set(1/t,0,0))}else{this._dragMode=-1;const{pointerTracker:e,rotationSpeed:i,camera:r,pivotMesh:o,tilesGroup:n,ellipsoid:a,domElement:d}=this;let m;if(r.isPerspectiveCamera){e.getCenterPoint(M),e.getPreviousCenterPoint(v),A(M.x,M.y,d,M),A(v.x,v.y,d,v),s.set(M.x,M.y,-1).unproject(r),D.set(v.x,v.y,-1).unproject(r),s.sub(D);const _=Math.max(...a.radius),R=this.getDistanceToCenter()-_,k=s.distanceTo(D)*R/r.near;m=7.5*1e-4*k/_}else m=c.mapLinear(r.zoom,this._getOrthographicTransitionZoom(),this._getMinOrthographicZoom(),.001,.005);e.getCenterPoint(M),e.getPreviousCenterPoint(v),z.subVectors(M,v).multiplyScalar(m);const h=-z.x*i,g=-z.y*i;f.setFromMatrixPosition(n.matrixWorld),W.set(1,0,0).transformDirection(r.matrixWorld),U.set(0,1,0).transformDirection(r.matrixWorld),l.setFromAxisAngle(W,g),r.quaternion.premultiply(l),P(f,l,x),r.matrixWorld.premultiply(x),l.setFromAxisAngle(U,h),r.quaternion.premultiply(l),P(f,l,x),r.matrixWorld.premultiply(x),r.matrixWorld.decompose(r.position,r.quaternion,s),o.visible=!1,this.inertiaDragMode=-1,z.multiplyScalar(1/t),e.getMoveDistance()/t<2*window.devicePixelRatio?this.dragInertia.lerp(z,.5):this.dragInertia.copy(z)}this._alignCameraUp(this.up)}_applyZoomedOutRotation(t,e){const{rotationSpeed:i,tilesGroup:r,camera:o}=this,n=-t*i,a=-e*i;o.updateMatrixWorld(),f.setFromMatrixPosition(r.matrixWorld),W.set(1,0,0).transformDirection(o.matrixWorld),U.set(0,1,0).transformDirection(o.matrixWorld),l.setFromAxisAngle(W,a),o.quaternion.premultiply(l),P(f,l,x),o.matrixWorld.premultiply(x),l.setFromAxisAngle(U,n),o.quaternion.premultiply(l),P(f,l,x),o.matrixWorld.premultiply(x),o.matrixWorld.decompose(o.position,o.quaternion,s)}_updateRotation(...t){this._rotationMode===1||this._isNearControls()?(this._rotationMode=1,super._updateRotation(...t)):(this.pivotMesh.visible=!1,this._rotationMode=-1),this._alignCameraUp(this.up)}_updateZoom(){const{zoomDelta:t,ellipsoid:e,zoomSpeed:i,zoomPoint:r,camera:o,maxZoom:n}=this,a=c.clamp(c.mapLinear(Math.abs(t),0,20,0,1),0,1);if(this._isNearControls()||t>0){if(this._updateZoomDirection(),t<0&&(this.zoomPointSet||this._updateZoomPoint())){p.set(0,0,-1).transformDirection(o.matrixWorld).normalize(),w.copy(this.up).multiplyScalar(-1),this.getUpDirection(r,G);const d=c.clamp(c.mapLinear(-G.dot(w),1,.95,0,1),0,1),m=1-p.dot(w),h=o.isOrthographicCamera?.05:1,g=c.clamp(a*3,0,1),_=Math.min(d*m*h*g,.1);w.lerpVectors(p,w,_).normalize(),l.setFromUnitVectors(p,w),P(r,l,x),o.matrixWorld.premultiply(x),o.matrixWorld.decompose(o.position,o.quaternion,w),this.zoomDirection.subVectors(r,o.position).normalize()}super._updateZoom()}else if(o.isPerspectiveCamera){const d=this._getPerspectiveTransitionDistance(),m=this._getMaxPerspectiveDistance(),h=c.mapLinear(this.getDistanceToCenter(),d,m,0,1);this._tiltTowardsCenter(c.lerp(0,.4,h*a)),this._alignCameraUpToNorth(c.lerp(0,.2,h*a));const g=this.getDistanceToCenter()-e.radius.x,_=t*g*i*.0025;this.getVectorToCenter(s).normalize(),this.camera.position.addScaledVector(s,_),this.camera.updateMatrixWorld(),this.zoomDelta=0}else{const d=this._getOrthographicTransitionZoom(),m=this._getMinOrthographicZoom(),h=c.mapLinear(o.zoom,d,m,0,1);this._tiltTowardsCenter(c.lerp(0,.4,h*a)),this._alignCameraUpToNorth(c.lerp(0,.2,h*a));const g=this.zoomDelta,_=Math.pow(.95,Math.abs(g*.05)),R=g>0?1/Math.abs(_):_;o.zoom=Math.max(this._getMinOrthographicZoom(),Math.min(n,o.zoom*R*i)),o.updateProjectionMatrix(),this.zoomDelta=0,this.zoomDirectionSet=!1}}_alignCameraUpToNorth(t){const{tilesGroup:e}=this;F.set(0,0,1).transformDirection(e.matrixWorld),this._alignCameraUp(F,t)}_alignCameraUp(t,e=null){const{camera:i}=this;p.set(0,0,-1).transformDirection(i.matrixWorld),W.set(-1,0,0).transformDirection(i.matrixWorld),E.crossVectors(t,p),e===null&&(e=1-Math.abs(p.dot(t)),e=c.mapLinear(e,0,1,-.01,1),e=c.clamp(e,0,1)**2),E.lerp(W,1-e).normalize(),l.setFromUnitVectors(W,E),i.quaternion.premultiply(l),i.updateMatrixWorld()}_tiltTowardsCenter(t){const{camera:e,tilesGroup:i}=this;p.set(0,0,-1).transformDirection(e.matrixWorld).normalize(),s.setFromMatrixPosition(i.matrixWorld).sub(e.position).normalize(),s.lerp(p,1-t).normalize(),l.setFromUnitVectors(p,s),e.quaternion.premultiply(l),e.updateMatrixWorld()}_getPerspectiveTransitionDistance(){const{camera:t,ellipsoid:e}=this;if(!t.isPerspectiveCamera)throw new Error;const i=Math.max(...e.radius),r=2*Math.atan(Math.tan(c.DEG2RAD*t.fov*.5)*t.aspect),o=i/Math.tan(c.DEG2RAD*t.fov*.5),n=i/Math.tan(r*.5);return Math.max(o,n)}_getMaxPerspectiveDistance(){const{camera:t,ellipsoid:e}=this;if(!t.isPerspectiveCamera)throw new Error;const i=Math.max(...e.radius),r=2*Math.atan(Math.tan(c.DEG2RAD*t.fov*.5)*t.aspect),o=i/Math.tan(c.DEG2RAD*t.fov*.5),n=i/Math.tan(r*.5);return 2*Math.max(o,n)}_getOrthographicTransitionZoom(){const{camera:t,ellipsoid:e}=this;if(!t.isOrthographicCamera)throw new Error;const i=t.top-t.bottom,r=t.right-t.left,o=Math.max(i,r),a=2*Math.max(...e.radius);return 2*o/a}_getMinOrthographicZoom(){const{camera:t,ellipsoid:e}=this;if(!t.isOrthographicCamera)throw new Error;const i=t.top-t.bottom,r=t.right-t.left,o=Math.min(i,r),a=2*Math.max(...e.radius);return .5*o/a}_getVirtualOrthoCameraPosition(t,e=this.camera){const{tilesGroup:i,ellipsoid:r}=this;if(!e.isOrthographicCamera)throw new Error;u.copy(i.matrixWorld).invert(),y.origin.copy(e.position),y.direction.set(0,0,-1).transformDirection(e.matrixWorld),y.applyMatrix4(u),T(y,r,D),D.applyMatrix4(i.matrixWorld);const o=e.top-e.bottom,n=e.right-e.left,a=Math.max(o,n)/e.zoom;p.set(0,0,-1).transformDirection(e.matrixWorld);const d=D.sub(e.position).dot(p);t.copy(e.position).addScaledVector(p,d-a*4)}_isNearControls(){const{camera:t}=this;return t.isPerspectiveCamera?this.getDistanceToCenter()<this._getPerspectiveTransitionDistance():t.zoom>this._getOrthographicTransitionZoom()}}const S=new b;class et{constructor(){this.tiles=null,this.needsUpdate=!1,this.cameraMatrices=new Map}init(t){this.tiles=t,this._needsUpdateCallback=()=>{this.needsUpdate=!0},this._onCameraAdd=({camera:e})=>{this.needsUpdate=!0,this.cameraMatrices.set(e,new b)},this._onCameraDelete=({camera:e})=>{this.needsUpdate=!0,this.cameraMatrices.delete(e)},t.addEventListener("dispose-model",this._needsUpdateCallback),t.addEventListener("camera-resolution-change",this._needsUpdateCallback),t.addEventListener("load-content",this._needsUpdateCallback),t.addEventListener("add-camera",this._onCameraAdd),t.addEventListener("delete-camera",this._onCameraDelete)}doTilesNeedUpdate(){const t=this.tiles;let e=!1;this.cameraMatrices.forEach((r,o)=>{S.copy(t.group.matrixWorld).premultiply(o.matrixWorldInverse).premultiply(o.projectionMatrixInverse),e=e||!S.equals(r),r.copy(S)});const i=this.needsUpdate;return this.needsUpdate=!1,i||e}dispose(){const t=this.tiles;t.removeEventListener("dispose-model",this._needsUpdateCallback),t.removeEventListener("camera-resolution-change",this._needsUpdateCallback),t.removeEventListener("content-load",this._needsUpdateCallback),t.removeEventListener("camera-add",this._onCameraAdd),t.removeEventListener("camera-delete",this._onCameraDelete)}}export{tt as G,et as U};
