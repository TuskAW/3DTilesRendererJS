import{g as rt,az as at,b as ct,V as g,p as ot,i as ht,k as f,j as st,E as lt,R as pt,o as dt,Q as nt,n as ut}from"./three.module-CrM3Sdgj.js";class mt extends rt{constructor(){super(new at(0,0),new ft),this.renderOrder=1/0}onBeforeRender(t){const e=this.material.uniforms;t.getSize(e.resolution.value)}updateMatrixWorld(){this.matrixWorld.makeTranslation(this.position)}dispose(){this.geometry.dispose(),this.material.dispose()}}class ft extends ct{constructor(){super({depthWrite:!1,depthTest:!1,transparent:!0,uniforms:{resolution:{value:new g},size:{value:15},thickness:{value:2},opacity:{value:1}},vertexShader:`

				uniform float pixelRatio;
				uniform float size;
				uniform float thickness;
				uniform vec2 resolution;
				varying vec2 vUv;

				void main() {

					vUv = uv;

					float aspect = resolution.x / resolution.y;
					vec2 offset = uv * 2.0 - vec2( 1.0 );
					offset.y *= aspect;

					vec4 screenPoint = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
					screenPoint.xy += offset * ( size + thickness ) * screenPoint.w / resolution.x;

					gl_Position = screenPoint;

				}
			`,fragmentShader:`

				uniform float size;
				uniform float thickness;
				uniform float opacity;

				varying vec2 vUv;
				void main() {

					float ht = 0.5 * thickness;
					float planeDim = size + thickness;
					float offset = ( planeDim - ht - 2.0 ) / planeDim;
					float texelThickness = ht / planeDim;

					vec2 vec = vUv * 2.0 - vec2( 1.0 );
					float dist = abs( length( vec ) - offset );
					float fw = fwidth( dist ) * 0.5;
					float a = smoothstep( texelThickness - fw, texelThickness + fw, dist );

					gl_FragColor = vec4( 1, 1, 1, opacity * ( 1.0 - a ) );

				}
			`})}}const Q=new g,Y=new g;class Pt{constructor(){this.domElement=null,this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new g,this.hoverSet=!1}reset(){this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new g,this.hoverSet=!1}updateFrame(){const{previousPositions:t,pointerPositions:e}=this;for(const i in e)t[i].copy(e[i])}setHoverEvent(t){(t.pointerType==="mouse"||t.type==="wheel")&&(this.getAdjustedPointer(t,this.hoverPosition),this.hoverSet=!0)}getLatestPoint(t){return this.pointerType!==null?(this.getCenterPoint(t),t):this.hoverSet?(t.copy(this.hoverPosition),t):null}getAdjustedPointer(t,e){const o=(this.domElement?this.domElement:t.target).getBoundingClientRect(),r=t.clientX-o.left,c=t.clientY-o.top;e.set(r,c)}addPointer(t){const e=t.pointerId,i=new g;this.getAdjustedPointer(t,i),this.pointerOrder.push(e),this.pointerPositions[e]=i,this.previousPositions[e]=i.clone(),this.startPositions[e]=i.clone(),this.getPointerCount()===1&&(this.pointerType=t.pointerType,this.buttons=t.buttons)}updatePointer(t){const e=t.pointerId;return e in this.pointerPositions?(this.getAdjustedPointer(t,this.pointerPositions[e]),!0):!1}deletePointer(t){const e=t.pointerId,i=this.pointerOrder;i.splice(i.indexOf(e),1),delete this.pointerPositions[e],delete this.previousPositions[e],delete this.startPositions[e],this.getPointerCount.length===0&&(this.buttons=0,this.pointerType=null)}getPointerCount(){return this.pointerOrder.length}getCenterPoint(t,e=this.pointerPositions){const i=this.pointerOrder;if(this.getPointerCount()===1||this.getPointerType()==="mouse"){const o=i[0];return t.copy(e[o]),t}else if(this.getPointerCount()===2){const o=this.pointerOrder[0],r=this.pointerOrder[1],c=e[o],p=e[r];return t.addVectors(c,p).multiplyScalar(.5),t}return null}getPreviousCenterPoint(t){return this.getCenterPoint(t,this.previousPositions)}getStartCenterPoint(t){return this.getCenterPoint(t,this.startPositions)}getMoveDistance(){return this.getCenterPoint(Q),this.getPreviousCenterPoint(Y),Q.sub(Y).length()}getTouchPointerDistance(t=this.pointerPositions){if(this.getPointerCount()<=1||this.getPointerType()==="mouse")return 0;const{pointerOrder:e}=this,i=e[0],o=e[1],r=t[i],c=t[o];return r.distanceTo(c)}getPreviousTouchPointerDistance(){return this.getTouchPointerDistance(this.previousPositions)}getStartTouchPointerDistance(){return this.getTouchPointerDistance(this.startPositions)}getPointerType(){return this.pointerType}isPointerTouch(){return this.getPointerType()==="touch"}getPointerButtons(){return this.buttons}isLeftClicked(){return!!(this.buttons&1)}isRightClicked(){return!!(this.buttons&2)}}const M=new ot,$=new ht,N=new f;function L(l,t,e){return e.makeTranslation(-l.x,-l.y,-l.z),M.makeRotationFromQuaternion(t),e.premultiply(M),M.makeTranslation(l.x,l.y,l.z),e.premultiply(M),e}function O(l,t,e,i){i.x=(l-e.offsetLeft)/e.clientWidth*2-1,i.y=-((t-e.offsetTop)/e.clientHeight)*2+1,i.isVector3&&(i.z=0)}function St(l,t,e){return t.intersectRay(l,e)?e:(M.makeScale(...t.radius).invert(),$.copy(l).applyMatrix4(M),N.set(0,0,0),$.closestPointToPoint(N,e).normalize(),M.makeScale(...t.radius),e.applyMatrix4(M))}function _t(l,t,e){const i=l.origin.length(),o=Math.acos(t/i);e.copy(l.origin).multiplyScalar(-1).normalize();const r=N.crossVectors(e,l.direction).normalize();e.multiplyScalar(-1).applyAxisAngle(r,-o).normalize().multiplyScalar(t)}function W(l,t,e){const{origin:i,direction:o}=l.ray;i.set(t.x,t.y,-1).unproject(e),o.set(t.x,t.y,1).unproject(e).sub(i),l.near=0,l.far=o.length(),l.camera=e,o.normalize()}const _=0,E=1,w=2,I=3,F=4,H=.05,Z=.025,D=new ot,U=new f,y=new f,j=new f,X=new f,b=new f,x=new nt,J=new st,S=new f,V=new f,B=new f,vt=new nt,A=new g,u=new g,K=new g,T=new g,q=new g,tt=new g,yt={type:"change"},et={type:"start"},it={type:"end"};class Dt extends lt{get enabled(){return this._enabled}set enabled(t){t!==this.enabled&&(this.resetState(),this.pointerTracker.reset(),this._enabled=t)}constructor(t=null,e=null,i=null,o=null){super(),this.domElement=null,this.camera=null,this.scene=null,this.tilesRenderer=null,this._enabled=!0,this.cameraRadius=5,this.rotationSpeed=1,this.minAltitude=0,this.maxAltitude=.45*Math.PI,this.minDistance=10,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.zoomSpeed=1,this.adjustHeight=!0,this.enableDamping=!1,this.dampingFactor=.15,this.reorientOnDrag=!0,this.scaleZoomOrientationAtEdges=!1,this.state=_,this.pointerTracker=new Pt,this.needsUpdate=!1,this.actionHeightOffset=0,this.pivotPoint=new f,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.zoomDirection=new f,this.zoomPoint=new f,this.zoomDelta=0,this.rotationInertia=new g,this.dragInertia=new f,this.pivotMesh=new mt,this.pivotMesh.raycast=()=>{},this.pivotMesh.scale.setScalar(.25),this.raycaster=new pt,this.raycaster.firstHitOnly=!0,this.up=new f(0,1,0),this.clock=new dt,this.fallbackPlane=new st(new f(0,1,0),0),this.useFallbackPlane=!0,this._detachCallback=null,this._upInitialized=!1,this._lastUsedState=_,this._zoomPointWasSet=!1,this._tilesOnChangeCallback=()=>this.zoomPointSet=!1,i&&this.attach(i),e&&this.setCamera(e),t&&this.setScene(t),o&&this.setTilesRenderer(o)}setScene(t){this.scene=t}setCamera(t){this.camera=t,this._upInitialized=!1,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.needsUpdate=!0,this.resetState()}setTilesRenderer(t){this.tilesRenderer&&this.tilesRenderer.removeEventListener("tile-visibility-change",this._tilesOnChangeCallback),this.tilesRenderer=t,this.tilesRenderer!==null&&(this.tilesRenderer.addEventListener("tile-visibility-change",this._tilesOnChangeCallback),this.scene===null&&this.setScene(this.tilesRenderer.group))}attach(t){if(this.domElement)throw new Error("EnvironmentControls: Controls already attached to element");this.domElement=t,this.pointerTracker.domElement=t,t.style.touchAction="none";let e=!1;const i=s=>{s.preventDefault()},o=s=>{s.key==="Shift"&&(e=!0)},r=s=>{s.key==="Shift"&&(e=!1)},c=s=>{s.preventDefault();const{camera:n,raycaster:m,domElement:C,up:k,pivotMesh:z,pointerTracker:v}=this;if(v.addPointer(s),this.needsUpdate=!0,v.isPointerTouch()){if(z.visible=!1,v.getPointerCount()===0)C.setPointerCapture(s.pointerId);else if(v.getPointerCount()>2){this.resetState();return}}v.getCenterPoint(u),O(u.x,u.y,C,u),W(m,u,n);const G=Math.abs(m.ray.direction.dot(k));if(G<H||G<Z)return;const R=this._raycast(m);R&&(v.getPointerCount()===2||v.isRightClicked()||v.isLeftClicked()&&e?(this.setState(v.isPointerTouch()?F:w),this.pivotPoint.copy(R.point),this.pivotMesh.position.copy(R.point),this.pivotMesh.updateMatrixWorld(),this.scene.add(this.pivotMesh)):v.isLeftClicked()&&(this.setState(E),this.pivotPoint.copy(R.point),this.pivotMesh.position.copy(R.point),this.pivotMesh.updateMatrixWorld(),this.scene.add(this.pivotMesh)))};let p=!1;const d=s=>{s.preventDefault(),this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.state!==_&&(this.needsUpdate=!0);const{pointerTracker:n}=this;n.setHoverEvent(s),n.updatePointer(s)&&n.isPointerTouch()&&n.getPointerCount()===2&&(p||(p=!0,queueMicrotask(()=>{p=!1,n.getCenterPoint(q);const m=n.getStartTouchPointerDistance(),C=n.getTouchPointerDistance(),k=C-m;if(this.state===_||this.state===F){n.getCenterPoint(q),n.getStartCenterPoint(tt);const z=2*window.devicePixelRatio,v=q.distanceTo(tt);(Math.abs(k)>z||v>z)&&(Math.abs(k)>v?(this.setState(I),this.zoomDirectionSet=!1):this.setState(w))}if(this.state===I){const z=n.getPreviousTouchPointerDistance();this.zoomDelta+=C-z}else this.state===w&&(this.pivotMesh.visible=!0)})))},h=s=>{const{pointerTracker:n}=this;n.deletePointer(s),n.getPointerType()==="touch"&&n.getPointerCount()===0&&t.releasePointerCapture(s.pointerId),this.resetState(),this.needsUpdate=!0},P=s=>{s.preventDefault();const{pointerTracker:n}=this;n.setHoverEvent(s),n.updatePointer(s),this.dispatchEvent(et);let m;switch(s.deltaMode){case 2:m=s.deltaY*100;break;case 1:m=s.deltaY*16;break;case 0:m=s.deltaY;break}const C=Math.sign(m),k=Math.log(Math.abs(m)+1);this.zoomDelta-=3*C*k,this.needsUpdate=!0,this._lastUsedState=I,this.dispatchEvent(it)},a=s=>{const{pointerTracker:n}=this;e=!1,s.buttons!==n.getPointerButtons()&&(n.deletePointer(s),this.resetState())};t.addEventListener("contextmenu",i),t.addEventListener("keydown",o),t.addEventListener("keyup",r),t.addEventListener("pointerdown",c),t.addEventListener("pointermove",d),t.addEventListener("pointerup",h),t.addEventListener("wheel",P),t.addEventListener("pointerenter",a),this._detachCallback=()=>{t.removeEventListener("contextmenu",i),t.removeEventListener("keydown",o),t.removeEventListener("keyup",r),t.removeEventListener("pointerdown",c),t.removeEventListener("pointermove",d),t.removeEventListener("pointerup",h),t.removeEventListener("wheel",P),t.removeEventListener("pointerenter",a)}}getUpDirection(t,e){e.copy(this.up)}getCameraUpDirection(t){this.getUpDirection(this.camera.position,t)}getPivotPoint(t){return this._lastUsedState===I?this._zoomPointWasSet?(t.copy(this.zoomPoint),t):null:this._lastUsedState===w||this._lastUsedState===E?(t.copy(this.pivotPoint),t):null}detach(){this.domElement=null,this._detachCallback&&(this._detachCallback(),this._detachCallback=null,this.pointerTracker.reset())}resetState(){this.state!==_&&this.dispatchEvent(it),this.state=_,this.pivotMesh.removeFromParent(),this.pivotMesh.visible=!0,this.actionHeightOffset=0}setState(t=this.state,e=!0){this.state!==t&&(this.state===_&&e&&this.dispatchEvent(et),this.pivotMesh.visible=!0,this.dragInertia.set(0,0,0),this.rotationInertia.set(0,0),this.state=t,t!==_&&t!==F&&(this._lastUsedState=t))}update(t=Math.min(this.clock.getDelta(),64/1e3)){if(!this.enabled||!this.camera||t===0)return;const{camera:e,cameraRadius:i,pivotPoint:o,up:r,state:c,adjustHeight:p}=this;e.updateMatrixWorld(),this.getCameraUpDirection(S),this._upInitialized||(this._upInitialized=!0,this.up.copy(S));const d=this._inertiaNeedsUpdate();if(this.needsUpdate||d){const a=this.zoomDelta;(c===I||a!==0)&&(this._updateZoom(),this.rotationInertia.set(0,0),this.dragInertia.set(0,0,0)),this._updatePosition(t),this._updateRotation(t),(c!==_||a!==0||d)&&this.dispatchEvent(yt),this.needsUpdate=!1}d&&this._updateInertiaDamping(t);const h=e.isOrthographicCamera?null:p&&this._getPointBelowCamera()||null,P=e.isOrthographicCamera?o:h&&h.point||null;if(this.getCameraUpDirection(S),this._setFrame(S,P),(this.state===E||this.state===w)&&this.actionHeightOffset!==0){const{actionHeightOffset:a}=this;e.position.addScaledVector(r,-a),o.addScaledVector(r,-a),h&&(h.distance-=a)}if(this.actionHeightOffset=0,h){const a=h.distance;if(a<i){const s=i-a;e.position.addScaledVector(r,s),o.addScaledVector(r,s),this.actionHeightOffset=s}}this.pointerTracker.updateFrame()}dispose(){this.detach()}_updateInertiaDamping(t){const{rotationInertia:e,dragInertia:i,enableDamping:o,dampingFactor:r}=this,c=Math.pow(2,-t/r);e.multiplyScalar(c),(e.lengthSq()<1e-8||!o)&&e.set(0,0),i.multiplyScalar(c),(i.lengthSq()<1e-8||!o)&&i.set(0,0,0)}_inertiaNeedsUpdate(){const{rotationInertia:t,dragInertia:e}=this;return t.lengthSq()!==0||e.lengthSq()!==0}_updateZoom(){const{zoomPoint:t,zoomDirection:e,camera:i,minDistance:o,maxDistance:r,pointerTracker:c,domElement:p,minZoom:d,maxZoom:h,zoomSpeed:P}=this;let a=this.zoomDelta;if(this.zoomDelta=0,!!c.getLatestPoint(u))if(i.isOrthographicCamera)if(this._updateZoomDirection(),this.zoomPointSet||this._updateZoomPoint()){V.unproject(i);const s=Math.pow(.95,Math.abs(a*.05)),n=a>0?1/Math.abs(s):s;i.zoom=Math.max(d,Math.min(h,i.zoom*n*P)),i.updateProjectionMatrix(),O(u.x,u.y,p,B),B.unproject(i),i.position.sub(B).add(V),i.updateMatrixWorld()}else{const s=Math.pow(.95,Math.abs(a*.05)),n=a>0?1/Math.abs(s):s;i.zoom=Math.max(d,Math.min(h,i.zoom*n*P)),i.updateProjectionMatrix()}else{this._updateZoomDirection();const s=y.copy(e);if(this.zoomPointSet||this._updateZoomPoint()){const n=t.distanceTo(i.position);if(a<0){const m=Math.min(0,n-r);a=a*n*P*.0025,a=Math.max(a,m)}else{const m=Math.max(0,n-o);a=a*(n-o)*P*.0025,a=Math.min(a,m)}i.position.addScaledVector(e,a),i.updateMatrixWorld()}else{const n=this._getPointBelowCamera();if(n){const m=n.distance;s.set(0,0,-1).transformDirection(i.matrixWorld),i.position.addScaledVector(s,a*m*.01),i.updateMatrixWorld()}}}}_updateZoomDirection(){if(this.zoomDirectionSet)return;const{domElement:t,raycaster:e,camera:i,zoomDirection:o,pointerTracker:r}=this;r.getLatestPoint(u),O(u.x,u.y,t,V),W(e,V,i),o.copy(e.ray.direction).normalize(),this.zoomDirectionSet=!0}_updateZoomPoint(){const{camera:t,zoomDirectionSet:e,zoomDirection:i,raycaster:o,zoomPoint:r,pointerTracker:c,domElement:p}=this;if(this._zoomPointWasSet=!1,!e)return!1;t.isOrthographicCamera&&c.getLatestPoint(A)?(O(A.x,A.y,p,A),W(o,A,t)):(o.ray.origin.copy(t.position),o.ray.direction.copy(i),o.near=0,o.far=1/0);const d=this._raycast(o);return d?(r.copy(d.point),this.zoomPointSet=!0,this._zoomPointWasSet=!0,!0):!1}_getPointBelowCamera(){const{camera:t,raycaster:e,up:i}=this;e.ray.direction.copy(i).multiplyScalar(-1),e.ray.origin.copy(t.position).addScaledVector(i,1e5),e.near=0,e.far=1/0;const o=this._raycast(e);return o&&(o.distance-=1e5),o}_updatePosition(t){const{raycaster:e,camera:i,pivotPoint:o,up:r,pointerTracker:c,domElement:p,state:d,dragInertia:h,enableDamping:P}=this;if(d===E){if(c.getCenterPoint(u),O(u.x,u.y,p,u),J.setFromNormalAndCoplanarPoint(r,o),W(e,u,i),Math.abs(e.ray.direction.dot(r))<H){const a=Math.acos(H);b.crossVectors(e.ray.direction,r).normalize(),e.ray.direction.copy(r).applyAxisAngle(b,a).multiplyScalar(-1)}if(this.getUpDirection(o,S),Math.abs(e.ray.direction.dot(S))<Z){const a=Math.acos(Z);b.crossVectors(e.ray.direction,S).normalize(),e.ray.direction.copy(S).applyAxisAngle(b,a).multiplyScalar(-1)}e.ray.intersectPlane(J,y)&&(U.subVectors(o,y),i.position.add(U),i.updateMatrixWorld(),U.multiplyScalar(1/t),c.getMoveDistance()/t<2*window.devicePixelRatio?h.lerp(U,.5):h.copy(U))}else P&&(i.position.addScaledVector(h,t),i.updateMatrixWorld())}_updateRotation(t){const{pivotPoint:e,pointerTracker:i,domElement:o,state:r,rotationInertia:c,enableDamping:p}=this;r===w?(i.getCenterPoint(u),i.getPreviousCenterPoint(K),T.subVectors(u,K).multiplyScalar(2*Math.PI/o.clientHeight),this._applyRotation(T.x,T.y,e),T.multiplyScalar(1/t),i.getMoveDistance()/t<2*window.devicePixelRatio?c.lerp(T,.5):c.copy(T)):p&&this._applyRotation(c.x*t,c.y*t,e)}_applyRotation(t,e,i){if(t===0&&e===0)return;const{camera:o,minAltitude:r,maxAltitude:c,rotationSpeed:p}=this,d=-t*p;let h=e*p;j.set(0,0,-1).transformDirection(o.matrixWorld).multiplyScalar(-1),this.getUpDirection(i,S),y.crossVectors(S,j).normalize(),X.set(1,0,0).transformDirection(o.matrixWorld).normalize();const a=Math.sign(y.dot(X))*S.angleTo(j);h>0?(h=Math.min(a-r-.01,h),h=Math.max(0,h)):(h=Math.max(a-c,h),h=Math.min(0,h)),x.setFromAxisAngle(S,d),L(i,x,D),o.matrixWorld.premultiply(D),b.set(-1,0,0).transformDirection(o.matrixWorld),x.setFromAxisAngle(b,h),L(i,x,D),o.matrixWorld.premultiply(D),o.matrixWorld.decompose(o.position,o.quaternion,y)}_setFrame(t,e){const{up:i,camera:o,state:r,zoomPoint:c,zoomDirection:p,zoomDirectionSet:d,zoomPointSet:h,reorientOnDrag:P,scaleZoomOrientationAtEdges:a}=this;o.updateMatrixWorld(),x.setFromUnitVectors(i,t);const s=r;if(d&&(h||this._updateZoomPoint())){if(this.getUpDirection(c,y),a){let n=Math.max(y.dot(i)-.6,0)/.4;n=ut.mapLinear(n,0,.5,0,1),n=Math.min(n,1),o.isOrthographicCamera&&(n*=.1),x.slerp(vt,1-n)}L(c,x,D),o.matrixWorld.premultiply(D),o.matrixWorld.decompose(o.position,o.quaternion,y),this.zoomDirectionSet=!1,this._updateZoomDirection()}else s===E&&P&&e&&(L(e,x,D),o.matrixWorld.premultiply(D),o.matrixWorld.decompose(o.position,o.quaternion,y));i.copy(t),o.updateMatrixWorld()}_raycast(t){const{scene:e,useFallbackPlane:i,fallbackPlane:o}=this,r=t.intersectObject(e)[0]||null;if(r)return r;if(i){const c=o;if(t.ray.intersectPlane(c,y))return{point:y.clone(),distance:t.ray.origin.distanceTo(y)}}return null}}export{E as D,Dt as E,_ as N,O as a,_t as b,St as c,L as m,W as s};
